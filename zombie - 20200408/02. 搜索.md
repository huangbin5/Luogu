# 1. 搜索
- 减少搜索量，提高时间空间效率
## 1.1. 数组 vs 容器
- 数据量大时不用容器，尽量转化为数组
### 1.1.1. [(洛谷)虫食算](https://www.luogu.com.cn/problem/P1092)
> 一个大写字母对应于一个数字，如果用map<char, int>将会很慢超时，可以把大写字母 - 'A'转化为数字然后使用数组
## 1.2. 剪枝
- 加快判断非法条件，去除无效搜索
### 1.2.1. [(洛谷)八皇后](https://www.luogu.com.cn/problem/P1219)
> 判断是否有皇后与之冲突，不用每次遍历所有冲突位置，可用bool数组记录每一列、每一主对角线、每一副对角线是否有皇后，判断时直接获取数组的值
### 1.2.2. [(洛谷)靶形数独](https://www.luogu.com.cn/problem/P1074)
> 用bool数组记录每一行、每一列、每一宫格是否包含某个数字；先确定可能情况较少的格子，再尝试不太容易确定的格子，否则会超时
## 1.3. 记忆化
- 记录搜索过的结果，避免重复搜索
### 1.3.1. [(洛谷)字符串变换](https://www.luogu.com.cn/problem/P1032)
> 按规则变换字符串，在不同位置先用规则1再用规则2和先用规则2再用规则1变换的结果是一样的，因此可以记录某个中间字符串是否曾经出现过
### 1.3.2. [(洛谷)引水入城](https://www.luogu.com.cn/problem/P1514)
> 暴力搜索第一行的每个点必然超时，可用数组记录每个点所能到达最后一行的左边和最右边的列，当搜索到某个点时，若其记录有值就可以直接使用
## 1.4. 状态压缩
- 用整数来表示整体状态，其中二进制的每一位代表某个元素的状态
### 1.4.1. [(HDU)胜利大逃亡(含钥匙)](http://acm.hdu.edu.cn/showproblem.php?pid=1429)
> 由于带着锁和钥匙，不能用基本的BFS标记是否访问过，再加一个维度key表示`拿到了哪些钥匙`的状态，用vis[x]\[y][key]标记是否访问过