# 1. 动态规划(DP)
## 1.1. 概述
### 1.1.1. 辨析
1. 动态规划与分治
1.1. 动态规划划分的问题具有**重叠子问题**，而分治划分的问题是不重叠的
1.2. 动态规划解决的是**最优解问题**，而分治不是
2. 动态规划与贪心
虽然二者都是求解最优问题，但动态规划是解决子问题后从中选择最好的，而贪心是选择其中一个子问题去解决，其正确性需要证明
### 1.1.2. 分类
1. 背包问题：01背包问题、完全背包问题、分组背包问题、二维背包、装箱问题、挤牛奶等
2. 线性动规：导弹拦截、合唱队形、挖地雷、建学校、剑客决斗等
3. 区间动规：石子合并、加分二叉树、统计单词个数、炮兵布阵等
4. 树形动规：贪吃的九头龙、二分查找树、聚会的欢乐、数字三角形等
## 1.2. 线性DP
### 1.2.1. 最大连续子序列和
- 求连续子序列中和的最大值
> - `状态设计`：dp[i]表示以a[i]为结尾的最大连续子序列和
> - `状态转移`：dp[i] = max{a[i], dp[i-1] + a[i]}
> - `结果`：max{dp[i]}
> - `复杂度`：$O(n)$
### 1.2.2. 最长上升子序列(LIS)
- 求上升子序列中最多的个数
> - `状态设计`：dp[i]表示以a[i]为结尾的最长上升子序列
> - `状态转移`：dp[i] = max{1, dp[j] + 1} (j < i && a[j] < a[i])
> - `结果`：max{dp[i]}
> - `复杂度`：$O(n^2)$
### 1.2.3. [(洛谷)导弹拦截](https://www.luogu.com.cn/problem/P1020)
- 拦截系统每次拦截的导弹高度不能高于前一次拦截的高度，求一套拦截系统最多能拦截多少颗导弹，要拦截全部导弹需要多少套拦截系统
> - 求一套拦截系统最多拦截多少导弹就是求`最长不上升子序列`，求至少要多少套拦截系统才能拦截全部导弹就是求`最长上升子序列`，复杂度为$O(n^2)$
> - `更优解`：用数组t记录不上升的一串导弹，t的长度为len，当遍历到a[i]时：
    1. 若t[len-1] >= a[i]，直接将a[i]加到t的末尾
    2. 若t[len-1] < a[i]，从t中查找第一个< a[i]的数tmp，令tmp = a[i]：若tmp为t[len-1]，则将其改为a[i]不至于使最长不上升子序列更短；若tmp不为t[len-1]，则将其改为a[i]对结果不会有任何影响
> - `复杂度`：$O(nlogn)$
### 1.2.4. [(洛谷)尼克的任务](https://www.luogu.com.cn/problem/P1280)
- 尼克有很多任务，当任务到来时如果尼克空闲，则必须由尼克挑一个来做，否则由同事去做，求尼克能获得的最大空暇时间
> - `状态设计`：dp[i]表示在i以后的时间内所能获得的最长空暇时间(t[k]为第k个任务的起始时间，a[k]为第k个任务的持续时间)
> - `状态转移`：$dp[i] =\begin{cases} dp[i+1] + 1 &\forall t[k] != i \\ max\{dp[i+a[k]]\} &\exists t[k] == i \end{cases}$
> - `结果`：dp[1]
> - `复杂度`：$O(n)$
## 1.3. 区间DP
- 递增遍历区间长度，长区间由短区间的结果计算得出
### 1.3.1. 最长公共子序列(LCS)
- 求两个序列相同子序列的最大长度
> - `状态设计`：dp\[i][j]表示字符串a前i个字符与字符串b前j个字符的LCS
> - `状态转移`：$dp[i][j] =\begin{cases} dp[i-1][j-1] + 1 &a[i] == b[j] \\ max\{dp[i-1][j], dp[i][j-1]\} &a[i] != b[j] \end{cases}$
> - `结果`：dp\[n][m]
> - `复杂度`：$O(nm)$
### 1.3.2. 最长回文子串
- 子串是连续的子序列，只求最长回文子串的长度
> - `状态设计`：dp\[i][j]表示第i ~ j个字符组成的子串是否回文串
> - `状态转移`：$dp[i][j] =\begin{cases} dp[i+1][j-1] &a[i] == a[j] \\ 0 &a[i] != a[j] \end{cases}$
> - `结果`：max{j - i + 1} (dp\[i][j] == 1)
> - `复杂度`：$O(n^2)$
### 1.3.3. 石子合并
#### 1.3.3.1. 线性石子合并
- 将一排石子相邻两堆不断合并，每次合并都要消耗正比于石子规模的体力，求合并为一堆石子需要消耗的最小体力
> - `状态设计`：dp\[i][j]表示合并第i ~ j堆石子的最小花费
> - `状态转移`：$dp[i][j] = min\{dp[i][k] + dp[k+1][j]\} + \sum\limits_{r=i}^j a_r$ $(i\le k<j)$
> - `结果`：dp\[0][n-1]
> - `复杂度`：$O(n^3)$
#### 1.3.3.2. 平行四边形优化
> - `优化`：记sele\[i][j]为得到dp\[i][j]所选取的k，初始时sele\[i][i] = i；更新dp\[i][j]时k不用从i取到j，而只要从sele\[i][j-1]取到sele\[i+1][j]
> - `复杂度`：$O(n^2)$
```C++
// 未优化
for(int k = i; k < j; ++k) {}
// 优化：注意sele[i + 1][j]有可能就是sele[j][j] = j，因此还是要判断k < j
for(int k = sele[i][j - 1]; k <= sele[i + 1][j] && k < j; ++k) {}
```
#### 1.3.3.3. [(洛谷)环形石子合并](https://www.luogu.com.cn/problem/P1880)
> - 环形石子可以在任意位置剪断变成线性石子，因此可以连续记录两遍石子，再按线性石子的做法求出所有的dp\[i][i+n-1]，取其中的最小值。可做平行四边形优化
> - 对于求最大花费，只能用$O(n^3)$的方法，不能做平行四边形优化
### 1.3.4. [(洛谷)统计单词个数](https://www.luogu.com.cn/problem/P1026)
- 有一个单词本和一个字符串，求将字符串分为k份得到每份所含单词个数之和的最大值
> - `状态设计1`：dp\[i][j]表示前i个字母分为j份时包含的最多单词数
> - `状态转移1`：dp\[i][j] = max{dp\[k][j-1] + cnt\[k+1][i]} $(j-1\le k\le i-1)$
> - `状态设计2`：cnt\[i][j]表示[i, j]中所含的单词数量
> - `状态转移2`：$cnt[i][j]=\begin{cases} cnt[i+1][j] &[i, j]中不包含以i开头的单词 \\ cnt[i+1][j]+1 &[i, j]中包含以i开头的单词\end{cases}$
> - `结果`：dp\[n][m]
> - `复杂度`：$O(n^2m)$
## 1.4. 多维DP
### 1.4.1. [(洛谷)传纸条](https://www.luogu.com.cn/problem/P1006)
- n行m列，从(1, 1)往右或下走到(n, m)再往左或上走回(1, 1)，沿途可以拾取财宝但不能经过同一个点，求拾取的最大财宝
> - `四维数组`：dp\[i][j]\[k][l]表示当两张纸条分别传到(i, j)和(k, l)时获得的好心程度，两张纸条可分别由(下，下)(下，右)(右，下)(右，右)传递过来，取其中最大值。注意判断(i, j)必须在(k, l)的左下方
> - `三维数组`：注意到i + j == k + l，因此可用dp[sum]\[i][j]表示两张纸条分别传到(sum - i, i)和(sum - j, j)时获得的好心程度。遍历的时候注意i和j表示的都是列
> - `滚动数组`：类似01背包，sum维度可省略，i和j改为倒序遍历
### 1.4.2. [(洛谷)最大正方形](https://www.luogu.com.cn/problem/P1387)
- 在只含0和1的矩阵里找出不含0的最大正方形
#### 1.4.2.1. DP
> - `状态设计`：dp\[i][j]表示以点(i, j)为右下角的最大正方形边长
> - `状态转移`：dp\[i][j] = max{dp\[i-1][j], dp\[i][j-1], dp\[i-1][j-1]} + 1
> - `结果`：max{dp\[i][j]}
> - `复杂度`：$O(n^2)$
#### 1.4.2.2. 暴力
> - `直观思想`：遍历每个点(i, j)，枚举边长k，判断该正方形是否符合要求，但如果一个个点判断会导致$O(n^5)$的高复杂度
> - `二维前缀和`：输入的时候记录sum\[i][j]表示点(i, j)及其左上方的所有点之和，sum\[i][j] = sum\[i-1][j] + sum\[i][j-1] - sum\[i-1][j-1] + a\[i][j]，判断正方形时可通过快速计算sum\[i+k-1][j+k-1] - sum\[i][j+k-1] - sum\[i+k-1][j] + sum\[i][j]是否等于$k^2$，复杂度降至$O(n^3)$
> - `二分`：枚举边长时可从当前最大边长到min(n, m)采用二分的方法，复杂度为$O(n^2logn)$
## 1.5. 状态压缩DP
### 1.5.1. [(HDU)方格取数](http://acm.hdu.edu.cn/showproblem.php?pid=1565)
- n * n的棋盘上每个格子都有一个非负数，取出若干个数，任意两数不相邻，求最大的和
> - `状态设计`：j表示一行中`取了哪些数`的状态，dp\[i][j]表示取到第i行状态为j时的最大和
> - `状态转移`：dp\[i][j] = max{dp\[i-1][k] + sum[j]}，其中j内部没有相邻的数，j和k没有相邻的数
> - `结果`：max{dp\[n][j]}
### 1.5.2. [(POJ)炮兵布阵](http://poj.org/problem?id=1185)
- n * m地图上有平原和山地，炮兵只能布置在平原上，炮兵能打到的最远范围为四面的两格位置，求最多能布置多少个炮兵
> - `状态设计`：和`方格取数`不同，这里会影响前两行的位置，因此需要加一维。j和k表示一行中`哪些位置布置了炮兵`的状态，dp[i]\[j][k]表示布置到第i行状态为j且第i - 1行状态为k时最多的炮兵数量
> - `状态转移`：炮兵不能打到前两行的炮兵，同时当前行的炮兵也不能相互打到(注意炮兵只能在平原上)
> - `结果`：max{dp[n]\[j][k]}
### 1.5.3. [(洛谷)吃奶酪](https://www.luogu.com.cn/problem/P1433)
- 平面上若干位置有奶酪，求从原点出发吃掉所有奶酪需要走的最短距离
> - `状态设计`：j表示`已经吃了哪些奶酪`的状态，dp\[i][j]表示从第i个点出发到达状态j时走的距离
> - `状态转移`：上两题中按i顺次遍历，因为dp[i]和dp[i-1]或者以及dp[i-2]相关；而本题中不能由从第i - 1个点出发转移到从第i个点出发，应该由与j码距为1的状态k转移到状态j
## 1.6. 数位DP
### 1.6.1. [(洛谷)windy数](https://www.luogu.com.cn/problem/P2657)
- windy数为相邻数字至少相差2的数(其中1-9为特殊windy数)，求(L, R)之间的windy数个数
> - `状态设计`：dp\[i][j]表示位数为i最高位为j的windy数个数
> - `状态转移`：dp\[i][j] = $\sum$dp\[i-1][k]，其中|j - k| > 1
> - `结果`：记sum[x]为[1, x)之间的windy数个数，则ans = sum[R+1] - sum[L]。sum[x]由满足下列条件的dp\[i][j]累加得到
    1. i < x的位数
    2. i == x的位数 && j < x的最高位
    3. i == x的位数 - 1 && j < x的次高位 && |x的次高位 - x的最高位| > 1 ... 以此类推直到个位或**相邻数字相差小于2**
## 1.7. 插头DP
### 1.7.1. [(UVa)Tiling Dominoes](https://www.luogu.com.cn/problem/UVA11270)
- 在一个n * m(n $\ge$ m且n * m $\le$ 100)棋盘上放置1 * 2的骨牌，求棋盘放满的方案数
> - `状态设计`：dp\[i][j]表示放到第i个格子时最后m个格子(当前行前面和上一行后面)摆放状态为j的方案数，初始时dp\[0][(1<<m)-1] = 1
> - `状态转移`：累加以下3种情况
    1. 第i个格子不放骨牌，则第i - m个格子(i上面)必须要有骨牌
    2. 第i个格子放横的骨牌，则第i - 1个格子(i左边)必须没有骨牌
    3. 第i个格子放竖的骨牌，则第i - m个格子必须没有骨牌
> - `结果`：dp\[n*m][(1<<m)-1]
> - `复杂度`：$O(2^mnm)$