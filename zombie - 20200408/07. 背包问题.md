# 1. 背包问题
## 1.1. 01背包
- `问题描述`：背包体积为v，有n种物品，每种物品一个，每个物品i有其占用的体积$c_i$和价值$w_i$，求背包所能容纳物品的最大价值
### 1.1.1. 背包问题最基本算法
- `状态设计`：dp\[i][j]表示前i个物品放入体积为j的背包中所能达到的最大价值
- `状态转移`：dp\[i][j] = max{dp\[i-1][j], dp\[i-1][j-c[i]] + w[i]}
- `滚动数组`：dp[j] = max{dp[j], dp[j-c[i]] + w[i]}
- `初始化`：关于背包问题有两种问法：一是**恰好装满**，此时dp[0] = 0，而dp[1...v] = $-\infty$，因为没有物品时只有体积为0时才恰好装满；二是**仅价值量最大**，此时dp[0...v] = 0，即没有物品时不管体积为多少，价值量最大只能为0
```C++
for(int j = 0; j <= v; ++j)
    dp[0][j] = 0;
for(int i = 1; i <= n; ++i)
    // 这里不能像滚动数组一样j到c[i]为止，因为滚动数组会自动继承上一轮的结果，而这里需要手动继承
    for(int j = 0; j <= v; ++j)
        if(j < c[i])
            dp[i][j] = dp[i - 1][j];
        else
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]);

for(int j = 0; j <= v; ++j)
    dp[j] = 0;
for(int i = 1; i <= n; ++i)
    for(int j = v; j >= c[i]; --j)
        dp[j] = max(dp[j], dp[j - c[i]] + w[i]);
```
### 1.1.2. 代码封装
```C++
void zeroOnePack(int cost, int weight) {
    for (int j = v; j >= cost; --j)
        dp[j] = max(dp[j], dp[j - cost] + weight);
}

for (int i = 1; i <= n; ++i)
    zeroOnePack(c[i], w[i]);
```
## 1.2. 完全背包
- `问题描述`：与01背包相比，每种物品有无数件
### 1.2.1. 按01背包的思路
- `基本思路`：dp\[i][j] = max{dp\[i-1][j], dp\[i-1][j-k\*c[i]] + k\*w[i]}，其中$k=0\ldots\lfloor\frac{v}{c[i]}\rfloor$，即要考虑物品i取0件、取1件、取2件……复杂度高
- `优化`：对于完全背包，可作如下优化：
  1. 对于两个物品i和j，如果c[i] < c[j]并且w[i] > w[j]，则可以去掉物品j，因为把j换成i有足够的空间并且价值更大。复杂度为$O(n^2)$
  2. 把所有体积超过v的物品都去掉，并且对体积相同的物品，只保留其中价值最大的。复杂度为$O(vn)$
### 1.2.2. 转化为01背包
- 把每种物品拆成有限个，有如下两种拆法：
  1. 因为每种物品最多只能装下$\lfloor\frac{v}{c[i]}\rfloor$件，因此可以将物品i拆成$\lfloor\frac{v}{c[i]}\rfloor$件体积、价值一样的物品
  2. 将物品i拆成体积为coe \* c[i]、价值为coe \* w[i]$(coe=2^0, 2^1, \ldots, 2^k)$的k + 1件物品，其中$2^k*c[i]\le v$，依据二进制原理，所有体积$\le v$的物品i都可由这k + 1件物品组成
### 1.2.3. 更优解
- `状态转移`：dp\[i][j] = max(dp\[i-1][j], dp\[i][j-c[i]] + w[i])
- `滚动数组`：dp[j] = max(dp[j], dp[j-c[i]] + w[i])，方程和01背包的一样，不同的是j遍历的次序是c[i]$\rightarrow$v
```C++
for(int i = 1; i <= n; ++i)
    // 从c[i]开始遍历。需要注意的是，如果使用二维数组，依然要从0开始手动继承 <= c[i]部分的值
    for(int j = c[i]; j <= v; ++j)
        dp[j] = max(dp[j], dp[j - c[i]] + w[i]);
```
### 1.2.4. 代码封装
```C++
void completePack(int cost, int weight) {
    for (int j = cost; j <= v; ++j)
        dp[j] = max(dp[j], dp[j - cost] + weight);
}

for (int i = 1; i <= n; ++i)
    completePack(c[i], w[i]);
```
## 1.3. 多重背包
- `问题描述`：每种物品有a[i]件
### 1.3.1. 按01背包的思路
- `基本思路`：dp\[i][j] = max{dp\[i-1][j], dp\[i-1][j-k\*c[i]] + k\*w[i]}，其中k = 0...a[i]，即要考虑物品i去0件、取1件、...、取a[i]件，复杂度高
### 1.3.2. 转化为01背包
1. 一种直观的方法就是将每种物品拆分成a[i]件相同的物品
2. 仍然借鉴二进制的思想，将物品i拆成体积为coe \* c[i]、价值为coe \* w[i]$(coe=2^0, 2^1, \ldots, 2^{k-1}, a[i]-2^k+1)$的k + 1件物品，其中$2^{k-1}*c[i] < v$，依据二进制原理，所有件数$\le$a[i]的物品i都可由这k + 1件物品组成，且所有件数 > a[i]的物品i必不能由这k + 1件物品组成
```C++
for (int i = 1; i < n; ++i) {
    // 若物品i的总体积超过了背包的体积，则可以转化为完全背包
    if (c[i] * a[i] >= v)
        for (int j = c[i]; j <= v; ++j)
            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);
    // 否则就按上述策略进行拆分，拆分后转化为01背包
    else {
        int coe = 1, amount = a[i];
        // 若还有物品，则继续拆分
        while (amount > 0) {
            int tmp = min(coe, amount);
            for (int j = v; j >= tmp * c[i]; --j)
                dp[j] = max(dp[j], dp[j - tmp * c[i] + tmp * w[i]);
            amount -= coe;
            coe <<= 1;
        }
    }
}
```
### 1.3.3. 代码封装
```C++
void multiplePack(int cost, int weight, int amount) {
    if (cost * amount >= v)
        completePack(cost, weight);
    else {
        int coe = 1;
        while (amount > 0) {
            int tmp = min(coe, amount);
            zeroOnePack(tmp * cost, tmp * weight);
            amount -= coe;
            coe <<= 1;
        }
    }
}

for (int i = 1; i < n; ++i)
    multiplePack(c[i], w[i], a[i]);
```
## 1.4. 混合背包
- 有的物品只有1件，有的物品有无数件，有的物品有一定数量
```C++
void mixedPack(int cost, int weight, int amount) {
    // 用0来表示无数件
    if (amount == 0)
        completePack(cost, weight);
    else if (amount == 1)
        zeroOnePack(cost, weight);
    else
        multiplePack(cost, weight, amount);
}

for (int i = 1; i <= n; ++i)
    mixedPack(c[i], w[i], a[i]);
```
## 1.5. 二维背包
- `问题描述`：对于每种物品需要付出两种代价c[i]和d[i]，总的可付出代价分别为v和u
### 1.5.1. 算法
- `状态设计`：只需对状态再加一维即可，dp\[i][j]\[k]表示前i种物品在两种代价分别为j和k时所能获得的最大价值
- `状态转移`：(01背包)dp\[i][j]\[k] = max{dp\[i-1][j]\[k], dp\[i-1][j-c[i]]\[k-d[i]] + w[i]}
- `滚动数组`：可以省略维度i，则dp\[j][k] = max{dp\[j][k], dp[j-c[i]]\[k-d[i]] + w[i]}
- `算法实现`：在原来循环j的后面加一层循环k即可，k的循环顺序与j相同
### 1.5.2. 一种隐含问法
- `限制条件`：总共最多取m件物品
- `二维代价`：可将件数作为代价u，每件物品的d[i] = 1
## 1.6. 分组背包
- `问题描述`：有n组物品，每组内有若干种物品，每组最多只能选择一种物品
- `状态设计`：dp\[i][j]表示前i组物品放入体积为j的背包中所能达到的最大价值
- `状态转移`：dp\[i][j] = max{dp\[i-1][j], dp\[i-1][j-c[k]] + w\[k](k为组i中的物品)}
```C++
for(int i = 1; i <= n; ++i)
    for(int j = v; j >= 0; --j)
    	// 注意：循环j必须放在循环k外面，这样才能保证dp[j-c[k]]一定是dp[i-1][j-c[k]]而不会出现dp[i][j-c[k]]的情况
        for(int k in group[i])
            if(j > c[k])
                dp[j] = max(dp[j], dp[j - c[k]] + w[k]);
```
## 1.7. 有依赖的背包
- `问题描述`：物品分为主件和附件，购买附件必须先购买主件。只考虑一层的依赖，即主件可以有多个附件，但附件只能对应一个主件，且附件不再成为别的物品的主件。(多层依赖关系要用树形DP，暂不考虑)
- `解决办法`：根据题目给的n和v的规模，有以下两种思路：
  1. 将主件的附件集的所有选择策略作为一个物品组，该物品组中的每个物品就是选择了主件和若干附件的策略，其体积和价值为累计和。如果主件有n个附件，则选择策略即物品组中物品的个数为$2^n$，附件不多的时候可以考虑这种方法
  2. 先对主件i的附件集做一次01背包，得到体积为0...v - c[i]时附件集的最大价值f[0...v-c[i]]，那么主件及其附件集就等价于v - c[i] + 1个物品的物品组，其中体积为k + c[i]的物品价值为f[k] + w[i]。$v<<2^n$的时候可以考虑这种方法
## 1.8. 背包的其它问法
### 1.8.1. 输出最优方案
- dp\[i][j] = max{dp\[i-1][j], dp\[i-1][j-c[i]] + w[i]}，用solu\[i][j]来记录状态转移方程选的是哪一项，solu\[i][j] = 0表示选的是dp\[i-1][j]亦即未选择物品i，solu\[i][j] = 1表示选的是dp\[i-1[j-c[i]] + w[i]亦即选择了物品i，输出的时候往前倒推
```C++
int i = n, j = v;
while(i > 0)
    if(solu[i][j] = 1) {
        cout << i << " ";
        j -= c[i];
    }

while(i > 0)
    // 也可以不记录solu[i][j]，直接在输出的时候判断
    if(dp[i][j] == dp[i - 1][j - c[i]] + w[i]) {
        cout << i << " ";
        j -= c[i];
    }
```
### 1.8.2. 输出字典序最小的最优方案
- 注意到：如果存在选了物品1的最优方案，那么字典序最小的最优方案一定包含物品1，问题则转化为物品2...n放入体积为v - c[1]的背包中；如果不存在选了物品1的最优方案，问题则转化为物品1...n放入体积为v的背包中。不管怎样都是物品i...n而非1...i的形式，因此需要先将物品的顺序颠倒
```C++
inverse();
// 此处的n是顺序颠倒之后的n，即原来的1
int i = n, j = v;
while(i > 0)
    if(dp[i][j] == dp[i - 1][j - c[i]] + w[i]) {
        cout << i << " ";
        j -= c[i];
    }
```
### 1.8.3. 求方案总数
- `问题描述`：求恰好装满背包的方案总数
- `解决办法`：只需要将状态转移方程中的max改为sum，即dp\[i][j] = dp\[i-1][j] + dp\[i-1][j-c[i]]，初始状态dp\[0][0] = 1，即没有物品时只有体积为0这一种刚好装满的方案
```C++
for(int i = 1; i <= n; ++i)
    for(int j = v; j >= c[i]; --j)
        dp[j] = dp[j] + dp[j - c[i]];
```
### 1.8.4. 求最优方案总数
- 记cnt\[i][j]为子问题的最优方案总数
```C++
for(int i = 1; i <= n; ++i)
    for(int j = 0; j <= v; ++j) {
        cnt[i][j] = 0;
        if(j < c[i])
            dp[i][j] = dp[i - 1][j];
        else {
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]);
            if(dp[i][j] == dp[i - 1][j - c[i]] + w[i])
                cnt[i][j] += cnt[i - 1][j - c[i]];
        }
        if(dp[i][j] == dp[i - 1][j])
            cnt[i][j] += cnt[i - 1][j];
    }
```
### 1.8.5. 求第k优解
- `状态设计`：原来的状态dp\[i][j]只记录了最优解一个值，现将状态扩充至k维，dp[i]\[j][k]，dp[i]\[j][1...k]表示前i个物品体积为j时的前k优解
- `状态转移`：max操作就改为合并dp[i-1]\[j][1...k]和dp\[i-1][j-c[i]]\[1...k] + w[i]的共2k个解，取前k个赋给dp[i]\[j][1...k]
## 1.9. 用搜索求解背包问题
### 1.9.1. DFS
- 复杂度为$O(2^n)$
```C++
// cur表示当前遍历的物品，curV表示已用体积，curW表示已有价值
void dfsPack(int cur, int curV, int curW) {
    if (curV > v)
        return;
    if (cur > n) {
        best = max(best, curW);
        return;
    }
    dfsPack(cur + 1, curV, curW);
    dfsPack(cur + 1, curV + c[cur], curW + w[cur]);
}

dfsPack(1, 0, 0);
```
### 1.9.2. 剪枝
1. `可行性剪枝`：假设题目要求装满背包，如果剩余物品全部放进去都装不满，则剪枝
2. `最优性剪枝`：如果剩余物品全部放进去都比当前最大价值还小，则剪枝
### 1.9.3. 搜索顺序
1. 将体积较大的物品放在前面，有利于`可行性剪枝`
2. 将性价比更高的物品放在前面，有利于`最优性剪枝`
3. 将数据随机打乱，可以避免出题人故意设置的陷阱
### 1.9.4. DP vs DFS
- DP复杂度为$O(nv)$；DFS复杂度为$O(2^n)$，只与n相关。当v很大时(如上百万)，DP可能超时，应选用DFS；当n很大时(如 > 30)，DFS可能超时，应选用DP
## 1.10. 例题
### 1.10.1. [(洛谷)多米诺骨牌](https://www.luogu.com.cn/problem/P1282)
- 若干骨牌上下两头都有一个数字，翻转骨牌会交换上下头的数字，求使上下数字之和相差最小的最少翻转次数
> - `转化思路`：把每个骨牌的两个数看作是一组物品，体积为每个数的大小，若翻转则价值为1不翻转则价值为0，计算上方数字之和为0...v所要翻转的最少次数
> - `状态设计`：dp\[i][j]表示前i个骨牌上方数字之和为j时所要翻转的最少次数
> - `状态转移`：dp\[i][j] = min{dp\[i-1][j-up[i]], dp\[i-1][j-down[i]] + 1}
> - `结果`：从所有数的总和sum / 2开始向两侧遍历，最先找到可以到达的上方数字之和j，结果为min{dp\[n][j], dp\[n][sum-j]}
### 1.10.2. [(洛谷)垃圾陷阱](https://www.luogu.com.cn/problem/P1156)
- 奶牛掉进井里了，给出每个垃圾投入井里的时间，奶牛可以将垃圾吃掉以维持生命，或用来垫高以试图逃生。若奶牛最终能逃出来则求逃出来的最早时间；若不能逃出来则求其能维持生命的最长时间
> - `状态设计`：按照垃圾投入的顺序，dp\[i][j]表示前i个垃圾达到高度j时所能维持的最大生命时间，初始时dp\[0][0] = 10
> - `状态转移`：dp\[i][j] = max{dp\[i-1][j] + e[i], dp\[i-1][j-h[i]]}
> - `特殊处理`：除了下标越界处理外，还要判断转移前所能维持的最大生命时间是否在垃圾i投入的时间之后
> - `结果`：
>   1. 若能成功逃出去，在可以选择堆放垃圾i并且堆放后的高度j$\ge$h时，垃圾i的投入时间t[i]就是最早逃出去的时间(j遍历的范围应为[0, h + max{h[i]}]
    2. 若逃不出去，则找到第一个dp\[i][0] = 0，答案即为dp\[i-1][0]，即依次吃掉每个垃圾能坚持的最大时间